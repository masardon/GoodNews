from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel, HttpUrl
from typing import List, Optional
from datetime import datetime, timezone
import os
import json
from apscheduler.schedulers.background import BackgroundScheduler

app = FastAPI()

# In-memory database (hanya untuk pengembangan)
articles_db = []

# Model data untuk artikel
class Article(BaseModel):
    title: str
    url: HttpUrl
    created_at: datetime = datetime.now(timezone.utc)
    updated_at: datetime = datetime.now(timezone.utc)
    status: str = "unpublished"
    user_id: Optional[str] = None
    publish_at: Optional[datetime] = None
    unpublish_at: Optional[datetime] = None

# Model data untuk user
class User(BaseModel):
    user_id: str
    role: str

# Simpan user admin ke dalam memori (gunakan env variable di production)
ADMIN_USER_ID = os.getenv("ADMIN_USER_ID", "admin")
users_db = {
    ADMIN_USER_ID: User(user_id=ADMIN_USER_ID, role="Admin")
}

# Dependency untuk mendapatkan user saat ini
def get_current_user():
    return users_db[ADMIN_USER_ID]

# Dependency untuk memastikan user adalah admin
def get_current_admin_user(user: User = Depends(get_current_user)):
    if user.role != "Admin":
        raise HTTPException(status_code=403, detail="Operation not permitted")
    return user

# Scheduler untuk update status artikel berdasarkan waktu
scheduler = BackgroundScheduler()
scheduler.start()

def check_article_status():
    """Memeriksa dan memperbarui status artikel berdasarkan publish_at dan unpublish_at."""
    now = datetime.now(timezone.utc)
    updated = False

    for article in articles_db:
        publish_time = article.publish_at
        unpublish_time = article.unpublish_at

        # Ubah ke "published" hanya jika waktu publish sudah tercapai dan status belum "published"
        if publish_time and publish_time <= now and article.status == "unpublished":
            article.status = "published"
            article.updated_at = now
            updated = True

        # Ubah ke "unpublished" hanya jika waktu unpublish sudah tercapai dan status masih "published"
        if unpublish_time and unpublish_time <= now and article.status == "published":
            article.status = "unpublished"
            article.updated_at = now
            updated = True

    if updated:
        save_articles_to_file()

# Menjalankan scheduler setiap 1 menit
scheduler.add_job(check_article_status, 'interval', minutes=1)

def save_articles_to_file():
    """Menyimpan database artikel ke file JSON."""
    with open("data/articles_db.json", "w") as file:
        json.dump([article.dict() for article in articles_db], file, default=str)

def load_articles_from_file():
    """Memuat artikel dari file JSON saat startup."""
    global articles_db
    try:
        with open("data/articles_db.json", "r") as file:
            articles_data = json.load(file)
            articles_db = [Article(**article) for article in articles_data]
    except (FileNotFoundError, json.JSONDecodeError):
        articles_db = []

@app.on_event("startup")
def on_startup():
    load_articles_from_file()

@app.on_event("shutdown")
def on_shutdown():
    save_articles_to_file()

@app.get("/")
def read_root():
    return {"message": "Welcome to the Article API"}

@app.get("/articles", response_model=List[Article])
def get_articles():
    """Mengembalikan hanya artikel yang sudah berstatus published."""
    return [article for article in articles_db if article.status == "published"]

@app.post("/articles", status_code=201)
def add_article(article: Article, user: User = Depends(get_current_admin_user)):
    """Menambahkan artikel baru dengan status default unpublished."""
    if any(a.url == article.url for a in articles_db):
        raise HTTPException(status_code=400, detail="Article with this URL already exists")
    article.created_at = datetime.now(timezone.utc)
    article.updated_at = datetime.now(timezone.utc)
    article.user_id = user.user_id
    articles_db.append(article)
    save_articles_to_file()
    return {"message": "Article added successfully", "article": article}

@app.put("/articles/{article_url}", response_model=Article)
def update_article(article_url: HttpUrl, updated_article: Article, user: User = Depends(get_current_admin_user)):
    """Memperbarui artikel berdasarkan URL."""
    for article in articles_db:
        if article.url == article_url:
            article.title = updated_article.title
            article.updated_at = datetime.now(timezone.utc)
            article.status = updated_article.status
            article.user_id = user.user_id
            article.publish_at = updated_article.publish_at
            article.unpublish_at = updated_article.unpublish_at
            save_articles_to_file()
            return article
    raise HTTPException(status_code=404, detail="Article not found")

@app.put("/articles/{article_url}/status", response_model=Article)
def update_article_status(article_url: HttpUrl, status: str, user: User = Depends(get_current_admin_user)):
    """Memperbarui status artikel secara manual oleh admin."""
    for article in articles_db:
        if article.url == article_url:
            if status not in ["published", "unpublished"]:
                raise HTTPException(status_code=400, detail="Invalid status value")
            article.status = status
            article.updated_at = datetime.now(timezone.utc)
            article.user_id = user.user_id
            save_articles_to_file()
            return article
    raise HTTPException(status_code=404, detail="Article not found")
